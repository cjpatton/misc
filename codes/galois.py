# galois.py -- Representations of Galois fields and extensions. Representations
# of polynomials over arbitrary fields. 

import numpy as np


### GF(2). ####################################################################

class GF(object):

  def __init__(self, val):
    if val == None: 
      self.val = 0
    else: 
      self.val = val

  def __add__(self, elem):
    return GF(self.val + elem.val)
  
  def __sub__(self, elem):
    return GF(self.val + elem.val)

  def __mul__(self, elem): 
    if not isinstance(elem, GF): 
      return elem * self # Scalar mult in extension of GF.
    else: return GF(self.val * elem.val)

  def __div__(self, elem):
    assert elem == GF(1)
    return self

  def __eq__(self, elem):
    return (self.val & 1) == (elem.val & 1)

  def __ne__(self, elem):
    return (self.val & 1) != (elem.val & 1)

  def __hash__(self):
    return self.val & 1

  def __repr__(self):
    return '1' if (self.val & 1) else '0'
  
  @classmethod
  def order(cls):
    return 2


### Extension field, GF(q^m). #################################################

class Extend:

  ''' Extension field of F of length m.

    GF(q^m) where q is the order of F. `_str` is a list of strings representing
    tuples of symbols in F. The index of the tuple corresponds to the power of 
    the field element. For example, `_str` can represent the extension field 
    generated by a primitive polynomial over F. 

        Field elements are represented symbollically. Suppose GF32 = Extend(GF, 
    5, ['10000', '01000' ... ]). Then GF32(0) represents the 0th power of the
    primitive elment, GF32(1) represents the 1st power of the primitive element, 
    etc. GF32(None) represents 0, the additive identity. 
  '''
  
  def __init__(self, F, m, _str):
    self.elements = []
    self.index = {}
    self.zero = tuple(F(None) for i in range(m))
    for (i, elem) in enumerate(_str):
      elem = tuple(map(lambda(b) : F(int(b)), elem))
      self.index[elem] = i 
      self.elements.append(elem)
    self.F = F
    self.m = m
    self.mod = (F.order() ** m) - 1
  
  def order(self):
    return self.mod + 1

  def __call__(self, i):
    return Element(self, i)
  
  def add(self, i, j):
    if i == None: x = self.zero
    else:         x = self.elements[i % self.mod]
    if j == None: y = self.zero
    else:         y = self.elements[j % self.mod]
    z = tuple(map(lambda (f, g) : f + g, zip(x, y)))
    if z == self.zero:
      return Element(self, None)
    return Element(self, self.index[z])
  
  def sub(self, i, j):
    if i == None: x = self.zero
    else:         x = self.elements[i % self.mod]
    if j == None: y = self.zero
    else:         y = self.elements[j % self.mod]
    z = tuple(map(lambda (f, g) : f - g, zip(x, y)))
    if z == self.zero:
      return Element(self, None)
    return Element(self, self.index[z])
      
  def mult(self, i, j):
    if i == None or j == None:
      return Element(self, None)
    return Element(self, (i + j) % self.mod)
  
  def scalarmult(self, f, i): # f \in F
    if i == None: x = self.zero
    else:         x = self.elements[i % self.mod]
    z = tuple(map(lambda (g) : f * g, x))
    if z == self.zero:
      return Element(self, None)
    return Element(self, self.index[z])

  def div(self, i, j):
    assert j != None
    if i == None: 
      return Element(self, None)
    return Element(self, (i - j) % self.mod)

  def __str__(self):
    res =  "\nGF(%d) = \n" % self.order()
    res += "  --  " + repr(Element(self, None)) + "\n"
    for i in range(len(self.elements)):
      res += "  %2d  " % (i) + repr(Element(self, i)) + "\n"
    return res


### Element of GF(q^m). #######################################################

class Element: 
  def __init__(self, ext, i):
    self.ext = ext
    self.i = i

  def __add__(self, elem):
    return self.ext.add(self.i, elem.i)

  def __sub__(self, elem):
    return self.ext.sub(self.i, elem.i)

  def __mul__(self, elem):
    if isinstance(elem, self.ext.F): # Scalar 
      return self.ext.scalarmult(elem, self.i)
    return self.ext.mult(self.i, elem.i)

  def __div__(self, elem):
    return self.ext.div(self.i, elem.i)
      
  def inverse(self):
    if self.i == None: 
      return Element(self.ext, None)
    i = self.ext.mod - (self.i % self.ext.mod)
    i %= self.ext.mod
    return Element(self.ext, i)

  def reciprocal(self):
    # TODO Test this with a field of characteristic > 2.
    if self.i == None:
      return Element(self.ext, None)
    return self.ext.sub(None, self.i)

  def __repr__(self):
    if self.i == None: 
      elem = self.ext.zero
    else:              
      elem = self.ext.elements[self.i % self.ext.mod]
    return ''.join(map(lambda (x) : repr(x), elem))

  def __eq__(self, elem):
    return self.i == elem.i 

  def __ne__(self, elem):
    return self.i != elem.i


### Polynomial object. ########################################################

class Poly:
  
  ''' Polynomial over an arbitrary field. 
  
    Coefficients are symbolic representations of field elements. For example, 
    Poly([1,0,0,1], GF), or Poly([None,None,0,None,27], GF32).  
  ''' 

  def __init__(self, coeff, F): # least to most significant coeff.
    self.F = F; self._deg = None
    self.v = np.array(map(lambda (val) : F(val), coeff))

  @classmethod
  def zero(cls, degree, F):
    return cls([ None for i in range(degree) ], F)

  def is_zero(self):
    for i in range(len(self)):
      if self[i] != self.F(None):
        return False
    return True
        
  def deg(self):
    if self._deg == None: 
      for i in reversed(range(len(self))):
        if self[i] != self.F(None):
          break
      self._deg = i
    return self._deg
  
  def __repr__(self):
    return str(self.v)
  
  def __len__(self):
    return self.v.shape[0]
    
  def __getitem__(self, i):
    return self.v[i]
  
  def __setitem__(self, i, val):
    self._deg = None # Degree may have changed.
    self.v[i] = val
  
  def __iter__(self):
    for i in range(len(self)):
      yield self.v[i]

  def __call__(self, val):
    res = self.F(None)
    acc = self.F(0) 
    for i in range(len(self)):
      res = res + (acc * self.v[i])  
      acc = acc * val
    return res

  def __eq__(self, p):
    p_deg = p.deg()
    if p_deg == self.deg():
      for i in range(p_deg + 1):
        if self[i] != p[i]:
          return False
      return True
    return False

  def __add__(self, a):
    a_deg = a.deg(); self_deg = self.deg()
    p_deg = max(a_deg, self_deg)
    p = Poly.zero(p_deg + 1, self.F)
    for i in range(self_deg + 1): 
      p[i] = self[i]
    for i in range(a_deg + 1):
      p[i] = p[i] + a[i]
    return p
  
  def __sub__(self, a):
    a_deg = a.deg(); self_deg = self.deg()
    p_deg = max(a_deg, self_deg)
    p = Poly.zero(p_deg + 1, self.F)
    for i in range(self_deg + 1): 
      p[i] = self[i]
    for i in range(a_deg + 1):
      p[i] = p[i] - a[i]
    return p

  def __mul__(self, a):
    a_deg = a.deg(); self_deg = self.deg()
    p = Poly.zero(a.deg() + self.deg() + 1, self.F)
    for i in range(a_deg + 1): 
      for j in range(self_deg + 1):
        p[i+j] = p[i+j] + (a[i] * self[j])
    return p

  def __div__(self, d):
    if d.is_zero():
      raise RuntimeError("Divide by zero-polynomial")
    r = self
    r_deg = r.deg(); d_deg = d.deg()
    q = Poly.zero(abs(r_deg - d_deg) + 1, self.F)
    while r_deg >= d_deg:
      
      t_deg = r_deg - d_deg
      t_coeff = r[r_deg] / d[d_deg]
      t = Poly.zero(t_deg + 1, self.F)
      t[t_deg] = t_coeff

      (r, q) = (r - (d * t), q + t)
      r_deg = r.deg()

    return (q, r)

  def deriv(self): 
    ''' Derivative of polynomial. '''
    self_deg = self.deg()
    p = Poly.zero(self_deg, self.F)
    for i in range(self_deg):
      for j in range(i+1):
        p[i] = p[i] + self[i+1]
    return p
        
      
